#==========================================================================================
# Module: ModelSetup.jl
# Description: Defines the data structures (Primitives, Results) and initialization 
#              functions for the heterogeneous preference model.
==========================================================================================#

using Parameters, Distributions, YAML, ForwardDiff
using OrderedCollections: OrderedDict
include("helpers.jl") # Lean fit_kde_psi (pure Julia)
#?=========================================================================================
#? Model Data Structures
#?=========================================================================================
@with_kw struct Primitives{T<:Real}
    # Functional form parameters
    A₀::T; A₁::T
    ψ₀::T; ϕ::T; ν::T
    c₀::T; χ::T
    γ₀::T; γ₁::T
    
    # --- CHANGE: Added parameter k for preference heterogeneity ---
    k::T 
    z_dist::Gamma # The distribution object for z ~ Gamma(k, 1)

    # Market parameters
    κ₀::T; κ₁::T
    β::T; δ::T; b::T; ξ::T

    # ψ_grid (remote productivity)
    n_ψ::Int; ψ_min::T; ψ_max::T
    ψ_grid::Vector{T}; ψ_pdf::Vector{T}; ψ_cdf::Vector{T}

    # h_grid (skill)
    aₕ::T; bₕ::T
    n_h::Int; h_min::T; h_max::T
    h_grid::Vector{T}; h_pdf::Vector{T}; h_cdf::Vector{T}
end

# Little helper so Duals and Reals both work
_unwrap(x) = try
    ForwardDiff.value(x)
catch
    x
end

function validate!(p::Primitives)
    βv, δv = _unwrap(p.β), _unwrap(p.δ)
    κ0v, κ1v = _unwrap(p.κ₀), _unwrap(p.κ₁)
    kv = _unwrap(p.k)

    0 ≤ βv ≤ 1 || throw(ArgumentError("β must be in [0,1], got $(βv)"))
    kv > 0 || throw(ArgumentError("k (Gamma shape) must be > 0, got $(kv)"))
    return p
end

# Convenience wrapper: build with keywords from @with_kw, then validate.
validated_Primitives(; kwargs...) = begin
    p = Primitives(; kwargs...)  # generated by @with_kw
    validate!(p)
end


# --- CHANGE: Results struct is simplified ---
# It only holds the core equilibrium objects solved for in the fixed-point iteration.
# Expected policies (alpha, wage) are computed AFTER the model is solved.
mutable struct Results{T<:Real}
    # Core Value Functions & Distributions
    S::Matrix{T} # Total match surplus S(h, ψ)
    U::Vector{T} # Unemployed worker value U(h)
    u::Vector{T} # Mass of unemployed workers u(h)
    n::Matrix{T} # Mass of employed workers n(h, ψ)
    v::Vector{T} # Vacancies v(ψ)

    # Aggregate Market Outcomes
    θ::T; p::T; q::T

    function Results(prim::Primitives{T}) where {T<:Real}
        n_h, n_ψ = prim.n_h, prim.n_ψ
        new{T}(
            zeros(T, n_h, n_ψ), # S
            zeros(T, n_h),      # U
            copy(prim.h_pdf),   # u (initialized to total population)
            zeros(T, n_h, n_ψ), # n
            zeros(T, n_ψ),      # v
            one(T), zero(T), zero(T) # θ, p, q
        )
    end
end

#?=========================================================================================
#? Initialization and Helper Functions
#?=========================================================================================

# --- CHANGE: New core helper function with exponential g(h,ψ) ---
# Given z, h, ψ, compute the analytical optimal α
function optimal_alpha_given_z(prim::Primitives, h, ψ, z)
    # Using the new, more stable exponential form for remote productivity
    g_val = prim.ψ₀ * exp(prim.ν * ψ + prim.ϕ * h)
    
    # The first-order condition is A1*h*(1-g) = c₀*z*(1-α)^χ
    # This only has an interior solution for α if g < 1.
    if g_val >= 1.0
        return 1.0 # Full remote is optimal
    end

    A_h = prim.A₀ + prim.A₁ * h
    c_i = prim.c₀ * z
    
    term = (A_h / c_i) * (1.0 - g_val)

    if term <= 0.0
        return 0.0 # Full in-person is optimal
    elseif term >= 1.0
        return 1.0 # Full remote is optimal
    else
        # Interior solution
        return 1.0 - term^(1.0 / prim.χ)
    end
end
function create_primitives_from_yaml(yaml_file::String)
    # This function loads 'k' from the YAML file and correctly constructs 
    # the Primitives object, including z_dist.
    config = YAML.load_file(yaml_file, dicttype=OrderedDict)
    mp = get(config, "ModelParameters", Dict())
    mg = get(config, "ModelGrids", Dict())

    # Helper to pull with default
    getp(k, default) = haskey(mp, k) ? mp[k] : default
    getg(k, default) = haskey(mg, k) ? mg[k] : default

    # Scalars
    A0 = parse(Float64, string(getp("A0", 0.0)))
    A1 = parse(Float64, string(getp("A1", 1.0)))
    psi0 = parse(Float64, string(getp("psi_0", getp("ψ₀", 1.0))))
    phi = parse(Float64, string(getp("phi", getp("ϕ", 0.3))))
    nu = parse(Float64, string(getp("nu", getp("ν", 1.0))))
    c0 = parse(Float64, string(getp("c0", getp("c₀", 0.2))))
    chi = parse(Float64, string(getp("chi", 2.0)))
    gamma0 = parse(Float64, string(getp("gamma0", getp("γ₀", 1.0))))
    gamma1 = parse(Float64, string(getp("gamma1", getp("γ₁", 0.5))))
    k = parse(Float64, string(getp("k", 2.0))) # Ensure 'k' is in your YAML file

    κ0 = parse(Float64, string(getp("kappa0", getp("κ₀", 1.0))))
    κ1 = parse(Float64, string(getp("kappa1", getp("κ₁", 1.0))))
    β = parse(Float64, string(getp("beta", 0.996)))
    δ = parse(Float64, string(getp("delta", 0.011)))
    b = parse(Float64, string(getp("b", 0.7)))
    ξ = parse(Float64, string(getp("xi", getp("ξ", 0.5))))

    # ψ-grid inputs
    n_ψ      = Int(mg["n_psi"])
    ψ_min    = Float64(mg["psi_min"])
    ψ_max    = Float64(mg["psi_max"])
    ψ_data   = mg["psi_data"]          # expect a table-like or vector
    ψ_column = mg["psi_column"]        # col name or index for ψ
    ψ_weight = get(mg, "psi_weight", nothing)  # optional

    # build ψ grid via KDE
    ψ_grid, ψ_pdf, ψ_cdf = fit_kde_psi(
        ψ_data, ψ_column;
        weights_col = ψ_weight,
        num_grid_points = n_ψ,
        boundary = (ψ_min, ψ_max)
    )

    # h-grid (Beta on [h_min, h_max])
    aₕ = Float64(mp["a_h"])
    bₕ = Float64(mp["b_h"])
    n_h   = Int(mg["n_h"])
    h_min = Float64(mg["h_min"])
    h_max = Float64(mg["h_max"])
    h_grid   = collect(range(h_min, h_max; length=n_h))
    h_scaled = (h_grid .- h_min) ./ (h_max - h_min)        # map to [0,1]
    beta_dist = Beta(aₕ, bₕ)
    h_pdf_raw = pdf.(beta_dist, h_scaled)
    h_pdf     = h_pdf_raw ./ sum(h_pdf_raw)
    h_cdf     = cumsum(h_pdf)
    h_cdf /= h_cdf[end]                              # ensure exact 1.0

    prim = validated_Primitives(; A₀=A0, A₁=A1, ψ₀=psi0, ϕ=phi, ν=nu, c₀=c0,
        χ=chi, γ₀=gamma0, γ₁=gamma1, k=k, z_dist=Gamma(k, 1.0),
        κ₀=κ0, κ₁=κ1, β=β, δ=δ, b=b, ξ=ξ,
        n_ψ=n_ψ, ψ_min=ψ_min, ψ_max=ψ_max, ψ_grid=ψ_grid, ψ_pdf=ψ_pdf, ψ_cdf=ψ_cdf,
        aₕ=aₕ, bₕ=bₕ, n_h=n_h, h_min=h_min, h_max=h_max, h_grid=h_grid, h_pdf=h_pdf, h_cdf=h_cdf)

    return prim
end
function initializeModel(yaml_file::String)
    prim = create_primitives_from_yaml(yaml_file)
    res = Results(prim)
    return prim, res
end
